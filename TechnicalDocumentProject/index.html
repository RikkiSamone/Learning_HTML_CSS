<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Project: Technical Documentation</title>
</head>

<body>
    <nav id="navbar">
        <header> Asynchronous Programming in Javascript</header>
        <ul>
            <li><a class="nav-link" href="#what_is_asynchronous_programming">What is Asynchronous Programming</a></li>
            <li><a class="nav-link" href="#core_concepts">Core Concepts</a></li>
            <li><a class="nav-link" href="#the_event_loop">The Event Loop</a></li>
            <li><a class="nav-link" href="#common_pitfalls_and_solutions">Common Pitfalls and Solutions</a></li>
            <li><a class="nav-link" href="#real_world_application">Real World Application</a></li>


    </nav>
    <main id="main-doc">
        <section class="main-section" id="what_is_asynchronous_programming">
            <header>What is Asynchronous Programming</header>
            <article>
                <p>Asynchronous programming is a paradigm that enables non-blocking operations, allowing a program to
                    handle multiple tasks simultaneously. This is especially crucial in web development, where tasks
                    like API calls or database queries can take time. By leveraging asynchronous programming, JavaScript
                    ensures that a program remains responsive instead of waiting for a task to complete.</p>
                <h5>Key Benefits</h5>
                <ul>
                    <li>Enhanced user experience by preventing freezing.</li>
                    <li>Efficient use of resources.</li>
                    <li>Better performance for I/O operations.</li>
                </ul>
            </article>
        </section>
        <br>

        <section class="main-section" id="core_concepts">
            <header>Core Concepts</header>
            <article>
                <p>JavaScript provides several tools to handle asynchronous code:</p>
                <ul>
                    <li><strong>Callbacks:</strong> Functions passed as arguments to other functions.</li>
                    <li><strong>Promises:</strong> Objects that represent a future value or error.</li>
                    <li><strong>Async/Await:</strong> Syntactic sugar over promises for more readable code.</li>
                </ul>
                <p>Here’s a simple example of a promise in action:</p>
                <p>javascript</p>
                <code>
           const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Data loaded successfully!");
    }, 2000);
  });
};

fetchData().then(response => console.log(response));</code>
                <p>When you need to perform several asynchronous tasks at once, Promise.all can be a powerful tool to
                    ensure all tasks are completed before proceeding.</p>
                <code>
  const fetchUser = () => {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id: 1, name: "John Doe" }), 1000);
  });
};

const fetchPosts = () => {
  return new Promise((resolve) => {
    setTimeout(() => resolve(["Post 1", "Post 2", "Post 3"]), 2000);
  });
};

const fetchData = async () => {
  try {
    console.log("Fetching data...");
    const [user, posts] = await Promise.all([fetchUser(), fetchPosts()]);
    console.log("User:", user);
    console.log("Posts:", posts);
  } catch (error) {
    console.error("Error fetching data:", error);
  }
};

fetchData();
</code>
            </article>
        </section>
        <br>
        <section class="main-section" id="the_event_loop">
            <header>The Event Loop</header>
            <article>
                <p> The event loop is a core concept behind JavaScript’s asynchronous behavior. It allows JavaScript to
                    execute non-blocking code by offloading tasks to the browser or Node.js. Once those tasks are
                    completed, their callbacks are added to the queue to be executed when the call stack is empty.</p>
                <h5>Key Elements of the Event Loop</h5>
                <ul>
                    <li><strong>Call Stack:</strong> Keeps track of function calls.</li>
                    <li><strong>Task Queue:</strong> Stores tasks to be executed.</li>
                    <li><strong>Web APIs:</strong> Handles tasks like timers, HTTP requests, or DOM events.</li>
                </ul>
                <p>Example:</p>
                <p>javascript</p>
                <code>
        console.log("Start");
        setTimeout(() => console.log("This runs     later"), 1000);
        console.log("End");</code>

                <p>Output:</p>
                <code>
          Start  
          <br>
          End  
          <br>
          This runs later
          </code>
            </article>
        </section>
        <br>
        <section class="main-section" id="common_pitfalls_and_solutions">
            <header>Common Pitfalls and Solutions</header>
            <article>

                <p>While asynchronous programming is powerful, it can introduce complexities:</p>
                <ul>
                    <li><strong>Callback Hell:</strong> Over-nested callbacks that make code hard to read.</li>
                    <ul>
                        <li><strong>Solution:</strong> Use promises or async/await.</li>
                    </ul>
                    <br>
                    <li><strong>Unhandled Errors:</strong> Forgetting to handle rejections in promises.</li>
                    <ul>
                        <li><strong>Solution:</strong> Use .catch() or try-catch blocks with async functions</li>
                    </ul>
                    <br>
                    <li><strong>Race Conditions:</strong> When two or more asynchronous operations access shared data
                        incorrectly.</li>
                    <ul>
                        <li><strong>Solution:</strong> Synchronize or sequence operations as needed.</li>
                    </ul>
                </ul>
            </article>
        </section>
        <br>
        <section class="main-section" id="real_world_application">
            <header>Real World Application</header>
            <article>
                <p>Asynchronous programming powers numerous web applications and services:</p>
                <ul>
                    <li><strong>Fetching API Data:</strong> Displaying dynamic content on web pages.</li>
                    <li><strong>Server-Side Rendering (SSR):</strong> Ensuring fast loading of HTML for search engines.
                    </li>
                    <li><strong>Handling Streams:</strong> Reading or writing large files without blocking operations.
                    </li>
                </ul>

                <p> Example of using async/await with API calls:</p>
                <p>javascript</p>
                <code>
  const fetchUserData = async () => {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/users");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Error fetching data:", error);
  }
};

fetchUserData();
</code>
                <p>Asynchronous programming makes JavaScript one of the most powerful tools for modern software
                    development.</p>
            </article>
        </section>
    </main>
</body>

</html>